import _slicedToArray from 'babel-runtime/helpers/slicedToArray';
import _regeneratorRuntime from 'babel-runtime/regenerator';
import _asyncToGenerator from 'babel-runtime/helpers/asyncToGenerator';
import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _createClass from 'babel-runtime/helpers/createClass';

// canvas 静态方法
var cans = function () {
  function cans(config, canvas) {
    var _this = this;

    _classCallCheck(this, cans);

    this.canvas = canvas || document.createElement('canvas');
    this.ctx = this.canvas.getContext('2d');
    this.canvas.width = config.width;
    this.canvas.height = config.height;
    this.cache = {};
    this.drawImage = function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(source, x, y, w, h) {
        var props = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};

        var borderWidth, borderColor, circle, shadow, img, _canvas;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                borderWidth = props.borderWidth, borderColor = props.borderColor, circle = props.circle, shadow = props.shadow;

                _this.ctx.strokeStyle = borderColor;
                _this.ctx.lineWidth = borderWidth;
                if (shadow) {
                  _this.setShadow(shadow, x, y, w, h);
                }

                if (!(typeof source === 'string')) {
                  _context.next = 10;
                  break;
                }

                _context.next = 7;
                return _this.getCache(source);

              case 7:
                _context.t0 = _context.sent;
                _context.next = 11;
                break;

              case 10:
                _context.t0 = source;

              case 11:
                img = _context.t0;

                if (circle) {
                  _canvas = _this.clipAvatar(img, w, h);

                  _this.ctx.drawImage(_canvas, x, y, w, h);
                  _this.ctx.beginPath();
                  _this.ctx.arc(x + w / 2, y + h / 2, w / 2, 0, 2 * Math.PI);
                  _this.ctx.stroke();
                } else {
                  _this.ctx.drawImage(img, x, y, w, h);
                  _this.ctx.strokeRect(x - borderWidth / 2, y - borderWidth / 2, w + borderWidth, h + borderWidth);
                }

              case 13:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, _this);
      }));

      return function (_x, _x2, _x3, _x4, _x5) {
        return _ref.apply(this, arguments);
      };
    }();
    this.drawLine = function (sx, sy, ex, ey, w, color) {
      _this.ctx.beginPath();
      _this.ctx.moveTo(sx, sy);
      _this.ctx.lineWidth = w;
      _this.ctx.lineTo(ex, ey);
      _this.ctx.strokeStyle = color;
      _this.ctx.stroke();
    };
    this.drawText = function (text, x, y) {
      var props = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var _props$color = props.color,
          color = _props$color === undefined ? '#000' : _props$color,
          _props$fontSize = props.fontSize,
          fontSize = _props$fontSize === undefined ? '10px' : _props$fontSize,
          _props$fontWeight = props.fontWeight,
          fontWeight = _props$fontWeight === undefined ? '' : _props$fontWeight,
          _props$fontStyle = props.fontStyle,
          fontStyle = _props$fontStyle === undefined ? '' : _props$fontStyle;

      _this.ctx.font = fontStyle + ' ' + fontWeight + ' ' + fontSize + ' PingFangSC-Regular';
      _this.ctx.fillStyle = color;
      _this.ctx.fillText(text, x, y + ~~fontSize.replace(/([\d]+)px/, '$1'));
    };
    this.toDataURL = function () {
      var _canvas2;

      (_canvas2 = this.canvas).toDataURL.apply(_canvas2, arguments);
    };
    this.reset = function () {
      _this.ctx.clearRect(0, 0, _this.canvas.width, _this.canvas.height);
    };
  }

  _createClass(cans, [{
    key: 'loadImg',
    value: function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(src) {
        var _this2 = this;

        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt('return', new Promise(function (resolve, reject) {
                  var img = new Image();
                  if (!_this2.isBase64(src) && !_this2.isSomeHost(src)) {
                    img.crossOrigin = 'Anonymous';
                  }
                  img.src = src;
                  img.addEventListener('load', loadEvt);
                  img.addEventListener('error', errorEvt);
                  function loadEvt() {
                    return resolve(img);
                    removeEvt();
                  }
                  function errorEvt() {
                    console.log('loadImg 图片加载失败: ' + src);
                    return resolve();
                    removeEvt();
                  }
                  function removeEvt() {
                    img.removeEventListener('load', loadEvt);
                    img.removeEventListener('error', errorEvt);
                  }
                }));

              case 1:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function loadImg(_x8) {
        return _ref2.apply(this, arguments);
      }

      return loadImg;
    }()
  }, {
    key: 'getCache',
    value: function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(src) {
        var key;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                key = this.isBase64(src) ? src.slice(-18) : src;

                if (Object.hasOwnProperty(this.cache, key)) {
                  _context3.next = 5;
                  break;
                }

                _context3.next = 4;
                return this.loadImg(src);

              case 4:
                this.cache[key] = _context3.sent;

              case 5:
                return _context3.abrupt('return', this.cache[key]);

              case 6:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getCache(_x9) {
        return _ref3.apply(this, arguments);
      }

      return getCache;
    }()
  }, {
    key: 'isBase64',
    value: function isBase64(src) {
      return (/^data:image\/jpg;base64,/.test(src)
      );
    }
  }, {
    key: 'isSomeHost',
    value: function isSomeHost(src) {
      var result = src.match(/^https?:\/\/[^\/\?#:]+/);
      if (result && result[0] === window.location.hostname) {
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: 'clipAvatar',
    value: function clipAvatar(imgObj, w, h) {
      var canvas = document.createElement('canvas');
      canvas.width = w;
      canvas.height = h;
      var ctx = canvas.getContext('2d');
      ctx.arc(w / 2, h / 2, w / 2, 0, 2 * Math.PI);
      ctx.clip();
      ctx.drawImage(imgObj, 0, 0, w, h);
      return canvas;
    }
  }, {
    key: 'setShadow',
    value: function setShadow(shadow) {
      var _match = (shadow || {}).match(/([\d]+)[\s]+([\d]+)[\s]+([\d]+)[\s]+([rgba#()\d,\.\s\w]+)/),
          _match2 = _slicedToArray(_match, 5),
          shadowOffsetX = _match2[1],
          shadowOffsetY = _match2[2],
          shadowBlur = _match2[3],
          shadowColor = _match2[4];

      this.ctx.shadowOffsetX = shadowOffsetX;
      this.ctx.shadowOffsetY = shadowOffsetY;
      this.ctx.shadowBlur = shadowBlur;
      this.ctx.shadowColor = shadowColor;
    }
  }]);

  return cans;
}();

export default cans;
