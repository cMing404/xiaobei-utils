import _extends from 'babel-runtime/helpers/extends';
import _regeneratorRuntime from 'babel-runtime/regenerator';
import _slicedToArray from 'babel-runtime/helpers/slicedToArray';
import _asyncToGenerator from 'babel-runtime/helpers/asyncToGenerator';
import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _createClass from 'babel-runtime/helpers/createClass';
import _objectWithoutProperties from 'babel-runtime/helpers/objectWithoutProperties';
import _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';
import _inherits from 'babel-runtime/helpers/inherits';

// canvas 静态方法
var px2Num = function px2Num(val) {
  return ~~val.replace(/([\d]+)px/, '$1');
};
var percent2Num = function percent2Num(v) {
  return ~~v.replace('%', '') / 100;
};

var Cansf = function () {
  function Cansf(canvas) {
    var _this = this;

    _classCallCheck(this, Cansf);

    this.canvas = canvas || document.createElement('canvas');
    this.ctx = this.canvas.getContext('2d');
    this.cache = {};
    this.drawImage = function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(source, x, y, w, h) {
        var props = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};

        var border, shadow, borderRadius, callback, bw, _border$match, _border$match2, borderWidth, borderStyle, borderColor, img, _canvas;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                border = props.border, shadow = props.shadow, borderRadius = props.borderRadius, callback = props.callback;
                bw = 0;

                if (shadow) {
                  _this.setShadow(shadow);
                } else {
                  _this.setShadow('0 0 0 transparent');
                }
                if (border) {
                  _border$match = border.match(/([\d]+(px)?)\s+(solid|dashed)\s+([#\w\d]+)/), _border$match2 = _slicedToArray(_border$match, 4), borderWidth = _border$match2[1], borderStyle = _border$match2[2], borderColor = _border$match2[3];

                  _this.ctx.strokeStyle = borderColor;
                  bw = px2Num(borderWidth);
                  _this.ctx.lineWidth = bw;
                  borderStyle === 'dashed' && _this.ctx.setLineDash([2, 2]);
                }
                _context.next = 6;
                return _this.getCache(source);

              case 6:
                img = _context.sent;

                if (borderRadius) {
                  _canvas = _this.imageRadiusClip(img, borderRadius);

                  _this.ctx.drawImage(_canvas, x, y, w, h);
                  border && _this.borderRadiusClip(x, y, w, h, borderRadius);
                } else {
                  _this.ctx.drawImage(img, x, y, w, h);
                  bw && _this.ctx.strokeRect(x - bw / 2, y - bw / 2, w + bw, h + bw);
                }
                _context.t0 = callback;

                if (!_context.t0) {
                  _context.next = 12;
                  break;
                }

                _context.next = 12;
                return callback(_this);

              case 12:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, _this);
      }));

      return function (_x, _x2, _x3, _x4, _x5) {
        return _ref.apply(this, arguments);
      };
    }();
    this.drawLine = function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(sx, sy, ex, ey, w, color, style, shadow, callback) {
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (shadow) {
                  _this.setShadow(shadow);
                } else {
                  _this.setShadow('0 0 0 transparent');
                }
                style === 'dashed' && _this.ctx.setLineDash([2, 2]);
                _this.ctx.beginPath();
                _this.ctx.moveTo(sx, sy);
                _this.ctx.lineWidth = w;
                _this.ctx.lineTo(ex, ey);
                _this.ctx.strokeStyle = color;
                _this.ctx.stroke();
                _context2.t0 = callback;

                if (!_context2.t0) {
                  _context2.next = 12;
                  break;
                }

                _context2.next = 12;
                return callback(_this);

              case 12:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, _this);
      }));

      return function (_x7, _x8, _x9, _x10, _x11, _x12, _x13, _x14, _x15) {
        return _ref2.apply(this, arguments);
      };
    }();
    this.drawText = function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(text, x, y) {
        var props = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

        var _props$color, color, _props$fontSize, fontSize, _props$fontWeight, fontWeight, _props$fontStyle, fontStyle, _props$letterSpacing, letterSpacing, width, textAlign, _props$hasBreak, hasBreak, lineHeight, shadow, callback, i;

        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _props$color = props.color, color = _props$color === undefined ? '#000' : _props$color, _props$fontSize = props.fontSize, fontSize = _props$fontSize === undefined ? '10px' : _props$fontSize, _props$fontWeight = props.fontWeight, fontWeight = _props$fontWeight === undefined ? '' : _props$fontWeight, _props$fontStyle = props.fontStyle, fontStyle = _props$fontStyle === undefined ? '' : _props$fontStyle, _props$letterSpacing = props.letterSpacing, letterSpacing = _props$letterSpacing === undefined ? '' : _props$letterSpacing, width = props.width, textAlign = props.textAlign, _props$hasBreak = props.hasBreak, hasBreak = _props$hasBreak === undefined ? false : _props$hasBreak, lineHeight = props.lineHeight, shadow = props.shadow, callback = props.callback;

                if (shadow) {
                  _this.setShadow(shadow);
                } else {
                  _this.setShadow('0 0 0 transparent');
                }
                _this.canvas.style.letterSpacing = letterSpacing ? letterSpacing : '0px';
                _this.ctx.font = fontStyle + ' ' + fontWeight + ' ' + fontSize + ' PingFangSC-Regular';
                _this.ctx.fillStyle = color;

                if (!width) {
                  _context3.next = 16;
                  break;
                }

                i = 0;

              case 7:
                if (!(i < text.length)) {
                  _context3.next = 16;
                  break;
                }

                if (!(_this.ctx.measureText(text.slice(0, i + 1)).width > width)) {
                  _context3.next = 13;
                  break;
                }

                _this.drawText(text.slice(0, i), x, y, _extends({}, props, {
                  hasBreak: true
                }));
                lineHeight = lineHeight ? px2Num(lineHeight) : px2Num(fontSize);
                _this.drawText(text.slice(i), x, y + lineHeight, props);
                return _context3.abrupt('return');

              case 13:
                i++;
                _context3.next = 7;
                break;

              case 16:
                if (!(textAlign && width || hasBreak)) {
                  _context3.next = 26;
                  break;
                }

                _context3.t0 = textAlign;
                _context3.next = _context3.t0 === 'right' ? 20 : _context3.t0 === 'center' ? 23 : 26;
                break;

              case 20:
                x = x + width;
                _this.ctx.textAlign = 'right';
                return _context3.abrupt('break', 26);

              case 23:
                x = (x + width) / 2;
                _this.ctx.textAlign = 'center';
                return _context3.abrupt('break', 26);

              case 26:
                _this.ctx.fillText(text, x, y + ~~fontSize.replace(/([\d]+)px/, '$1'));
                _context3.t1 = callback;

                if (!_context3.t1) {
                  _context3.next = 31;
                  break;
                }

                _context3.next = 31;
                return callback(_this, _this.ctx.measureText(text));

              case 31:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, _this);
      }));

      return function (_x16, _x17, _x18) {
        return _ref3.apply(this, arguments);
      };
    }();
    this.reset = function () {
      _this.ctx.clearRect(0, 0, _this.canvas.width, _this.canvas.height);
    };
  }

  _createClass(Cansf, [{
    key: 'loadImg',
    value: function () {
      var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(src) {
        var _this2 = this;

        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                return _context4.abrupt('return', new Promise(function (resolve, reject) {
                  var img = new Image();
                  if (!_this2.isBase64(src) && !_this2.isSomeHost(src)) {
                    img.crossOrigin = 'Anonymous';
                  }
                  img.src = src;
                  img.addEventListener('load', loadEvt);
                  img.addEventListener('error', errorEvt);
                  function loadEvt() {
                    removeEvt();
                    return resolve(img);
                  }
                  function errorEvt() {
                    console.log('loadImg 图片加载失败: ' + src);
                    removeEvt();
                    return resolve();
                  }
                  function removeEvt() {
                    img.removeEventListener('load', loadEvt);
                    img.removeEventListener('error', errorEvt);
                  }
                }));

              case 1:
              case 'end':
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function loadImg(_x20) {
        return _ref4.apply(this, arguments);
      }

      return loadImg;
    }()
  }, {
    key: 'getCache',
    value: function () {
      var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(source) {
        var key, img;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!(typeof source === 'string')) {
                  _context5.next = 10;
                  break;
                }

                key = this.isBase64(source) ? source.slice(-18) : source;

                if (Object.hasOwnProperty(this.cache, key)) {
                  _context5.next = 7;
                  break;
                }

                _context5.next = 5;
                return this.loadImg(source);

              case 5:
                img = _context5.sent;

                if (img) {
                  this.cache[key] = img;
                }

              case 7:
                return _context5.abrupt('return', this.cache[key] || null);

              case 10:
                return _context5.abrupt('return', source);

              case 11:
              case 'end':
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getCache(_x21) {
        return _ref5.apply(this, arguments);
      }

      return getCache;
    }()
  }, {
    key: 'isBase64',
    value: function isBase64(src) {
      return (/^data:image\/jpg;base64,/.test(src)
      );
    }
  }, {
    key: 'isSomeHost',
    value: function isSomeHost(src) {
      var result = src.match(/^https?:\/\/[^\/\?#:]+/);
      if (result && result[0] === window.location.hostname) {
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: 'imageRadiusClip',
    value: function imageRadiusClip(imgObj, r) {
      var canvas = document.createElement('canvas');
      var w = imgObj.width;
      var h = imgObj.height;
      canvas.width = w;
      canvas.height = h;
      var ctx = canvas.getContext('2d');
      var pattern = ctx.createPattern(imgObj, 'no-repeat');
      var min_size = Math.min(w, h);
      var x = 0;
      var y = 0;
      r = min_size * percent2Num(r);
      if (r > min_size / 2) r = min_size / 2;
      // 开始绘制
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.arcTo(x + w, y, x + w, y + h, r);
      ctx.arcTo(x + w, y + h, x, y + h, r);
      ctx.arcTo(x, y + h, x, y, r);
      ctx.arcTo(x, y, x + w, y, r);
      ctx.closePath();
      ctx.fillStyle = pattern;
      ctx.fill();
      return canvas;
    }
  }, {
    key: 'borderRadiusClip',
    value: function borderRadiusClip(x, y, w, h, r) {
      var min_size = Math.min(w, h);
      r = min_size * percent2Num(r);
      this.ctx.beginPath();
      this.ctx.moveTo(x + r, y);
      this.ctx.arcTo(x + w, y, x + w, y + h, r);
      this.ctx.arcTo(x + w, y + h, x, y + h, r);
      this.ctx.arcTo(x, y + h, x, y, r);
      this.ctx.arcTo(x, y, x + w, y, r);
      this.ctx.closePath();
      this.ctx.stroke();
    }
  }, {
    key: 'setShadow',
    value: function setShadow(shadow) {
      var _match = (shadow || {}).match(/([\d]+)[\s]+([\d]+)[\s]+([\d]+)[\s]+([rgba#()\d,\.\s\w]+)/),
          _match2 = _slicedToArray(_match, 5),
          shadowOffsetX = _match2[1],
          shadowOffsetY = _match2[2],
          shadowBlur = _match2[3],
          shadowColor = _match2[4];

      this.ctx.shadowOffsetX = shadowOffsetX;
      this.ctx.shadowOffsetY = shadowOffsetY;
      this.ctx.shadowBlur = shadowBlur;
      this.ctx.shadowColor = shadowColor;
    }
  }, {
    key: 'output',
    value: function output(tiny) {
      if (!tiny) {
        return this.canvas.toDataURL();
      } else {
        return this.canvas.toDataURL('image/jpeg', tiny);
      }
    }
  }]);

  return Cansf;
}();

var Cans = function (_Cansf) {
  _inherits(Cans, _Cansf);

  function Cans(canvas) {
    _classCallCheck(this, Cans);

    return _possibleConstructorReturn(this, (Cans.__proto__ || Object.getPrototypeOf(Cans)).call(this, canvas));
  }

  _createClass(Cans, [{
    key: 'render',
    value: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(config) {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.setCanvas(config);
                _context.next = 3;
                return this.resolveImages(config.images);

              case 3:
                _context.next = 5;
                return this.resolveTexts(config.texts);

              case 5:
                _context.next = 7;
                return this.resolveLines(config.lines);

              case 7:
                return _context.abrupt('return', this);

              case 8:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function render(_x) {
        return _ref.apply(this, arguments);
      }

      return render;
    }()
  }, {
    key: 'setCanvas',
    value: function setCanvas(_ref2) {
      var background = _ref2.background,
          width = _ref2.width,
          height = _ref2.height;

      width && (this.canvas.width = width);
      height && (this.canvas.height = height);
      this.ctx.fillStyle = background;
      this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }
  }, {
    key: 'resolveLines',
    value: function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        var lines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

        var i, _lines$i, sx, sy, ex, ey, lineWidth, color, style, shadow, callback;

        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                i = 0;

              case 1:
                if (!(i < lines.length)) {
                  _context2.next = 8;
                  break;
                }

                _lines$i = lines[i], sx = _lines$i.sx, sy = _lines$i.sy, ex = _lines$i.ex, ey = _lines$i.ey, lineWidth = _lines$i.lineWidth, color = _lines$i.color, style = _lines$i.style, shadow = _lines$i.shadow, callback = _lines$i.callback;
                _context2.next = 5;
                return this.drawLine(sx, sy, ex, ey, lineWidth, color, style, shadow, callback);

              case 5:
                i++;
                _context2.next = 1;
                break;

              case 8:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function resolveLines() {
        return _ref3.apply(this, arguments);
      }

      return resolveLines;
    }()
  }, {
    key: 'resolveTexts',
    value: function () {
      var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
        var texts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

        var i, _texts$i, text, x, y, arg;

        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                i = 0;

              case 1:
                if (!(i < texts.length)) {
                  _context3.next = 8;
                  break;
                }

                _texts$i = texts[i], text = _texts$i.text, x = _texts$i.x, y = _texts$i.y, arg = _objectWithoutProperties(_texts$i, ['text', 'x', 'y']);
                _context3.next = 5;
                return this.drawText(text, x, y, arg);

              case 5:
                i++;
                _context3.next = 1;
                break;

              case 8:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function resolveTexts() {
        return _ref4.apply(this, arguments);
      }

      return resolveTexts;
    }()
  }, {
    key: 'resolveImages',
    value: function () {
      var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {
        var _this2 = this;

        var images = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

        var res, i, img, _images$i, x, y, width, height, border, shadow, borderRadius, callback;

        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return Promise.all(images.map(function (v) {
                  return _this2.getCache(v.source);
                }));

              case 2:
                res = _context4.sent;
                i = 0;

              case 4:
                if (!(i < res.length)) {
                  _context4.next = 15;
                  break;
                }

                img = res[i];

                if (img) {
                  _context4.next = 9;
                  break;
                }

                console.log('图片加载失败 无法渲染: ' + images[i].source);
                return _context4.abrupt('break', 15);

              case 9:
                _images$i = images[i], x = _images$i.x, y = _images$i.y, width = _images$i.width, height = _images$i.height, border = _images$i.border, shadow = _images$i.shadow, borderRadius = _images$i.borderRadius, callback = _images$i.callback;
                _context4.next = 12;
                return this.drawImage(img, x, y, width, height, {
                  border: border,
                  shadow: shadow,
                  borderRadius: borderRadius,
                  callback: callback
                });

              case 12:
                i++;
                _context4.next = 4;
                break;

              case 15:
              case 'end':
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function resolveImages() {
        return _ref5.apply(this, arguments);
      }

      return resolveImages;
    }()
  }]);

  return Cans;
}(Cansf);

export default Cans;
