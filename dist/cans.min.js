import _extends from 'babel-runtime/helpers/extends';
import _regeneratorRuntime from 'babel-runtime/regenerator';
import _slicedToArray from 'babel-runtime/helpers/slicedToArray';
import _asyncToGenerator from 'babel-runtime/helpers/asyncToGenerator';
import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _createClass from 'babel-runtime/helpers/createClass';
import _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';
import _inherits from 'babel-runtime/helpers/inherits';

// canvas 静态方法
var px2Num = function px2Num(val) {
  return ~~val.replace(/([\d]+)px/, '$1');
};
var percent2Num = function percent2Num(v) {
  return ~~v.replace('%', '') / 100;
};

var cansf = function () {
  function cansf(config, canvas) {
    var _this = this;

    _classCallCheck(this, cansf);

    this.canvas = canvas || document.createElement('canvas');
    this.ctx = this.canvas.getContext('2d');
    this.canvas.width = config.width;
    this.canvas.height = config.height;
    this.cache = {};
    this.drawImage = function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(source, x, y, w, h) {
        var props = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};

        var border, shadow, borderRadius, bw, _border$match, _border$match2, borderWidth, borderStyle, borderColor, img, _canvas;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                border = props.border, shadow = props.shadow, borderRadius = props.borderRadius;
                bw = 0;

                if (shadow) {
                  _this.setShadow(shadow);
                } else {
                  _this.setShadow('0 0 0 transparent');
                }
                if (border) {
                  _border$match = border.match(/([\d]+(px)?)\s+(solid|dashed)\s+([#\w\d]+)/), _border$match2 = _slicedToArray(_border$match, 4), borderWidth = _border$match2[1], borderStyle = _border$match2[2], borderColor = _border$match2[3];

                  _this.ctx.strokeStyle = borderColor;
                  bw = px2Num(borderWidth);
                  _this.ctx.lineWidth = bw;
                  borderStyle === 'dashed' && _this.ctx.setLineDash([2, 2]);
                }

                if (!(typeof source === 'string')) {
                  _context.next = 10;
                  break;
                }

                _context.next = 7;
                return _this.getCache(source);

              case 7:
                _context.t0 = _context.sent;
                _context.next = 11;
                break;

              case 10:
                _context.t0 = source;

              case 11:
                img = _context.t0;

                if (borderRadius) {
                  _canvas = _this.imageRadiusClip(img, borderRadius);

                  _this.ctx.drawImage(_canvas, x, y, w, h);
                  border && _this.borderRadiusClip(x, y, w, h, borderRadius);
                } else {
                  _this.ctx.drawImage(img, x, y, w, h);
                  bw && _this.ctx.strokeRect(x - bw / 2, y - bw / 2, w + bw, h + bw);
                }

              case 13:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, _this);
      }));

      return function (_x, _x2, _x3, _x4, _x5) {
        return _ref.apply(this, arguments);
      };
    }();
    this.drawLine = function (sx, sy, ex, ey, w, color, style, shadow) {
      if (shadow) {
        _this.setShadow(shadow);
      } else {
        _this.setShadow('0 0 0 transparent');
      }
      style === 'dashed' && _this.ctx.setLineDash([2, 2]);
      _this.ctx.beginPath();
      _this.ctx.moveTo(sx, sy);
      _this.ctx.lineWidth = w;
      _this.ctx.lineTo(ex, ey);
      _this.ctx.strokeStyle = color;
      _this.ctx.stroke();
    };
    this.drawText = function (text, x, y) {
      var props = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var _props$color = props.color,
          color = _props$color === undefined ? '#000' : _props$color,
          _props$fontSize = props.fontSize,
          fontSize = _props$fontSize === undefined ? '10px' : _props$fontSize,
          _props$fontWeight = props.fontWeight,
          fontWeight = _props$fontWeight === undefined ? '' : _props$fontWeight,
          _props$fontStyle = props.fontStyle,
          fontStyle = _props$fontStyle === undefined ? '' : _props$fontStyle,
          _props$letterSpacing = props.letterSpacing,
          letterSpacing = _props$letterSpacing === undefined ? '' : _props$letterSpacing,
          width = props.width,
          textAlign = props.textAlign,
          _props$hasBreak = props.hasBreak,
          hasBreak = _props$hasBreak === undefined ? false : _props$hasBreak,
          lineHeight = props.lineHeight,
          shadow = props.shadow;

      if (shadow) {
        _this.setShadow(shadow);
      } else {
        _this.setShadow('0 0 0 transparent');
      }
      _this.canvas.style.letterSpacing = letterSpacing ? letterSpacing : '0px';
      _this.ctx.font = fontStyle + ' ' + fontWeight + ' ' + fontSize + ' PingFangSC-Regular';
      _this.ctx.fillStyle = color;
      if (width) {
        for (var i = 0; i < text.length; i++) {
          if (_this.ctx.measureText(text.slice(0, i + 1)).width > width) {
            _this.drawText(text.slice(0, i), x, y, _extends({}, props, {
              hasBreak: true
            }));
            lineHeight = lineHeight ? px2Num(lineHeight) : px2Num(fontSize);
            _this.drawText(text.slice(i), x, y + lineHeight, props);
            return;
          }
        }
      }
      if (textAlign && width || hasBreak) {
        switch (textAlign) {
          case 'right':
            x = x + width;
            _this.ctx.textAlign = 'right';
            break;
          case 'center':
            x = (x + width) / 2;
            _this.ctx.textAlign = 'center';
            break;
        }
      }
      _this.ctx.fillText(text, x, y + ~~fontSize.replace(/([\d]+)px/, '$1'));
      return _this.ctx.measureText(text);
    };
    this.toDataURL = function () {
      var _canvas2;

      return (_canvas2 = this.canvas).toDataURL.apply(_canvas2, arguments);
    };
    this.reset = function () {
      _this.ctx.clearRect(0, 0, _this.canvas.width, _this.canvas.height);
    };
  }

  _createClass(cansf, [{
    key: 'loadImg',
    value: function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(src) {
        var _this2 = this;

        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt('return', new Promise(function (resolve, reject) {
                  var img = new Image();
                  if (!_this2.isBase64(src) && !_this2.isSomeHost(src)) {
                    img.crossOrigin = 'Anonymous';
                  }
                  img.src = src;
                  img.addEventListener('load', loadEvt);
                  img.addEventListener('error', errorEvt);
                  function loadEvt() {
                    removeEvt();
                    return resolve(img);
                  }
                  function errorEvt() {
                    console.log('loadImg 图片加载失败: ' + src);
                    removeEvt();
                    return resolve();
                  }
                  function removeEvt() {
                    img.removeEventListener('load', loadEvt);
                    img.removeEventListener('error', errorEvt);
                  }
                }));

              case 1:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function loadImg(_x8) {
        return _ref2.apply(this, arguments);
      }

      return loadImg;
    }()
  }, {
    key: 'getCache',
    value: function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(src) {
        var key, img;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                key = this.isBase64(src) ? src.slice(-18) : src;

                if (Object.hasOwnProperty(this.cache, key)) {
                  _context3.next = 6;
                  break;
                }

                _context3.next = 4;
                return this.loadImg(src);

              case 4:
                img = _context3.sent;

                if (img) {
                  this.cache[key] = img;
                }

              case 6:
                return _context3.abrupt('return', this.cache[key] || null);

              case 7:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getCache(_x9) {
        return _ref3.apply(this, arguments);
      }

      return getCache;
    }()
  }, {
    key: 'isBase64',
    value: function isBase64(src) {
      return (/^data:image\/jpg;base64,/.test(src)
      );
    }
  }, {
    key: 'isSomeHost',
    value: function isSomeHost(src) {
      var result = src.match(/^https?:\/\/[^\/\?#:]+/);
      if (result && result[0] === window.location.hostname) {
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: 'imageRadiusClip',
    value: function imageRadiusClip(imgObj, r) {
      var canvas = document.createElement('canvas');
      var w = imgObj.width;
      var h = imgObj.height;
      canvas.width = w;
      canvas.height = h;
      var ctx = canvas.getContext('2d');
      var pattern = ctx.createPattern(imgObj, 'no-repeat');
      var min_size = Math.min(w, h);
      var x = 0;
      var y = 0;
      r = min_size * percent2Num(r);
      if (r > min_size / 2) r = min_size / 2;
      // 开始绘制
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.arcTo(x + w, y, x + w, y + h, r);
      ctx.arcTo(x + w, y + h, x, y + h, r);
      ctx.arcTo(x, y + h, x, y, r);
      ctx.arcTo(x, y, x + w, y, r);
      ctx.closePath();
      ctx.fillStyle = pattern;
      ctx.fill();
      return canvas;
    }
  }, {
    key: 'borderRadiusClip',
    value: function borderRadiusClip(x, y, w, h, r) {
      var min_size = Math.min(w, h);
      r = min_size * percent2Num(r);
      this.ctx.beginPath();
      this.ctx.moveTo(x + r, y);
      this.ctx.arcTo(x + w, y, x + w, y + h, r);
      this.ctx.arcTo(x + w, y + h, x, y + h, r);
      this.ctx.arcTo(x, y + h, x, y, r);
      this.ctx.arcTo(x, y, x + w, y, r);
      this.ctx.closePath();
      this.ctx.stroke();
    }
  }, {
    key: 'setShadow',
    value: function setShadow(shadow) {
      var _match = (shadow || {}).match(/([\d]+)[\s]+([\d]+)[\s]+([\d]+)[\s]+([rgba#()\d,\.\s\w]+)/),
          _match2 = _slicedToArray(_match, 5),
          shadowOffsetX = _match2[1],
          shadowOffsetY = _match2[2],
          shadowBlur = _match2[3],
          shadowColor = _match2[4];

      this.ctx.shadowOffsetX = shadowOffsetX;
      this.ctx.shadowOffsetY = shadowOffsetY;
      this.ctx.shadowBlur = shadowBlur;
      this.ctx.shadowColor = shadowColor;
    }
  }]);

  return cansf;
}();

var Cans = function (_Cansf) {
  _inherits(Cans, _Cansf);

  function Cans(config, canvas) {
    _classCallCheck(this, Cans);

    var width = config.width,
        height = config.height,
        background = config.background;

    var _this = _possibleConstructorReturn(this, (Cans.__proto__ || Object.getPrototypeOf(Cans)).call(this, {
      width: width,
      height: height
    }, canvas));

    _this.setBackground(background);
    _this.resolveImages(config.images).then(function () {
      _this.resolveTexts(config.texts);
      _this.resolveLines(config.lines);
    });
    return _this;
  }

  _createClass(Cans, [{
    key: 'setBackground',
    value: function setBackground(background) {
      this.ctx.fillStyle = background;
      this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }
  }, {
    key: 'resolveLines',
    value: function resolveLines() {
      var _this2 = this;

      var lines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      lines.forEach(function (v) {
        _this2.drawLine(v.sx, v.sy, v.ex, v.ey, v.lineWidth, v.color, v.style);
      });
    }
  }, {
    key: 'resolveTexts',
    value: function resolveTexts() {
      var _this3 = this;

      var texts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      texts.forEach(function (v) {
        _this3.drawText(v.text, v.x, v.y, {
          fontSize: v.fontSize,
          fontWeight: v.fontWeight,
          color: v.color,
          letterSpacing: v.letterSpacing,
          fontStyle: v.fontStyle,
          width: v.width,
          textAlign: v.textAlign,
          lineHeight: v.lineHeight,
          shadow: v.shadow
        });
      });
    }
  }, {
    key: 'resolveImages',
    value: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        var _this4 = this;

        var images = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var res;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return Promise.all(images.map(function (v) {
                  return _this4.getCache(v.source);
                }));

              case 2:
                res = _context2.sent;

                // 下面虽然异步 但实际执行的同步代码
                res.map(function () {
                  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(img, index) {
                    var _images$index, x, y, width, height, border, shadow, borderRadius;

                    return _regeneratorRuntime.wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            if (img) {
                              _context.next = 3;
                              break;
                            }

                            console.log('图片加载失败 无法渲染: ' + images[index].source);
                            return _context.abrupt('return', null);

                          case 3:
                            _images$index = images[index], x = _images$index.x, y = _images$index.y, width = _images$index.width, height = _images$index.height, border = _images$index.border, shadow = _images$index.shadow, borderRadius = _images$index.borderRadius;
                            _context.next = 6;
                            return _this4.drawImage(img, x, y, width, height, {
                              border: border,
                              shadow: shadow,
                              borderRadius: borderRadius
                            });

                          case 6:
                            return _context.abrupt('return', _context.sent);

                          case 7:
                          case 'end':
                            return _context.stop();
                        }
                      }
                    }, _callee, _this4);
                  }));

                  return function (_x4, _x5) {
                    return _ref2.apply(this, arguments);
                  };
                }());

              case 4:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function resolveImages() {
        return _ref.apply(this, arguments);
      }

      return resolveImages;
    }()
  }]);

  return Cans;
}(cansf);

export default Cans;
